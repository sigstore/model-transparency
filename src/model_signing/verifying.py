# Copyright 2024 The Sigstore Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""High level API for the verification interface of model_signing library.

Users should use this API to verify the integrity of models, rather than using
the internals of the library. We guarantee backwards compatibility only for the
API defined in `hashing.py`, `signing.py` and `verifying.py` at the root level
of the library.
"""

from collections.abc import Iterable
import os
import pathlib
import sys

from model_signing import hashing
from model_signing._signing import sign_certificate as certificate
from model_signing._signing import sign_ec_key as ec_key
from model_signing._signing import sign_sigstore as sigstore


if sys.version_info >= (3, 11):
    from typing import Self
else:
    from typing_extensions import Self


class Config:
    """Configuration to use when verifying models against signatures.

    The verification configuration is used to decouple between serialization
    formats and verification types. Having configured the serialization format,
    this configuration class supports setting up the verification parameters.
    These should match the signing one.
    """

    def __init__(self):
        """Initializes the default configuration for verification."""
        self._hashing_config = hashing.Config()
        self._verifier = None

    def verify(self, model_path: os.PathLike, signature_path: os.PathLike):
        """Verifies that a model conforms to a signature.

        Args:
            model_path: the path to the model to verify.

        Raises:
            ValueError: No verifier has been configured.
        """
        if self._verifier is None:
            raise ValueError("Attempting to verify with no configured verifier")

        signature = sigstore.Signature.read(pathlib.Path(signature_path))
        expected_manifest = self._verifier.verify(signature)
        actual_manifest = self._hashing_config.hash(model_path)

        if actual_manifest != expected_manifest:
            raise ValueError("Signature mismatch")

    def set_hashing_config(self, hashing_config: hashing.Config) -> Self:
        """Sets the new configuration for hashing models.

        Args:
            hashing_config: the new hashing configuration.

        Returns:
            The new signing configuration.
        """
        self._hashing_config = hashing_config
        return self

    def use_sigstore_verifier(
        self, *, identity: str, oidc_issuer: str, use_staging: bool = False
    ) -> Self:
        """Configures the verification of signatures produced by Sigstore.

        The verifier in this configuration is changed to one that performs
        verification of Sigstore signatures (sigstore bundles signed by
        keyless signing via Sigstore).

        Args:
            identity: The expected identity that has signed the model.
            oidc_issuer: The expected OpenID Connect issuer that provided the
              certificate used for the signature.
            use_staging: Use staging configurations, instead of production. This
              is supposed to be set to True only when testing. Default is False.

        Return:
            The new verification configuration.
        """
        self._verifier = sigstore.Verifier(
            identity=identity, oidc_issuer=oidc_issuer, use_staging=use_staging
        )
        return self

    def use_elliptic_key_verifier(self, *, public_key: pathlib.Path) -> Self:
        """Configures the verification of signatures generated by a private key.

        The verifier in this configuration is changed to one that performs
        verification of sgistore bundles signed by an elliptic curve private
        key. The public key used in the configuration must match the private key
        used during signing.

        Args:
            public_key: The path to the public key to verify with.

        Return:
            The new verification configuration.
        """
        self._verifier = ec_key.Verifier(public_key)
        return self

    def use_certificate_verifier(
        self, *, certificate_chain: Iterable[pathlib.Path] = frozenset()
    ) -> Self:
        """Configures the verification of signatures generated by a certificate.

        The verifier in this configuration is changed to one that performs
        verification of sgistore bundles signed by a signing certificate.

        Args:
            certificate_chain: Certificate chain to establish root of trust. If
              empty, the operating system's one is used.

        Return:
            The new verification configuration.
        """
        self._verifier = certificate.Verifier(certificate_chain)
        return self
